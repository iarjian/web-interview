import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.2eafe199.js";const b=JSON.parse('{"title":"面试官：说说你对贪心算法、回溯算法的理解？应用场景？","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/design2.md","filePath":"algorithm/design2.md","lastUpdated":1694418005000}'),p={name:"algorithm/design2.md"},o=l(`<h1 id="面试官-说说你对贪心算法、回溯算法的理解-应用场景" tabindex="-1">面试官：说说你对贪心算法、回溯算法的理解？应用场景？ <a class="header-anchor" href="#面试官-说说你对贪心算法、回溯算法的理解-应用场景" aria-label="Permalink to &quot;面试官：说说你对贪心算法、回溯算法的理解？应用场景？&quot;">​</a></h1><p><img src="https://static.vue-js.com/1d49eae0-2e8e-11ec-a752-75723a64e8f5.png" alt=""></p><h2 id="一、贪心算法" tabindex="-1">一、贪心算法 <a class="header-anchor" href="#一、贪心算法" aria-label="Permalink to &quot;一、贪心算法&quot;">​</a></h2><p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p><p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p><p>举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p><p>如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 = 5 + 5 + 1 的选择，这种情况是最优的</p><p>但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 = 4 + 1 + 1这样选择，这种情况结果就不是最优的选择</p><p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p><p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p><p>至于是否选择贪心算法，主要看是否有如下两大特性：</p><ul><li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li><li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li></ul><h2 id="二、回溯算法" tabindex="-1">二、回溯算法 <a class="header-anchor" href="#二、回溯算法" aria-label="Permalink to &quot;二、回溯算法&quot;">​</a></h2><p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p><p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p><p>使用回溯算法的问题，有如下特性：</p><ul><li>有很多路，例如一个矩阵的方向或者树的路径</li><li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li><li>通常使用递归来模拟所有的路</li></ul><p>常见的伪代码如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">backtrack</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">路径</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">选择列表</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">满足结束条件</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">result</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">路径</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  for 选择 </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">选择列表</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    做选择</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">backtrack</span><span style="color:#E1E4E8;">(路径, 选择列表)</span></span>
<span class="line"><span style="color:#E1E4E8;">    撤销选择</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">backtrack</span><span style="color:#24292E;">(</span><span style="color:#E36209;">路径</span><span style="color:#24292E;">, </span><span style="color:#E36209;">选择列表</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">if</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">满足结束条件</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">result</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">路径</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  for 选择 </span><span style="color:#D73A49;">of</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">选择列表</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    做选择</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">backtrack</span><span style="color:#24292E;">(路径, 选择列表)</span></span>
<span class="line"><span style="color:#24292E;">    撤销选择</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>重点解决三个问题：</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表</li><li>结束条件</li></ul><p>例如经典使用回溯算法为解决全排列的问题，如下：</p><p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p><ul><li>用递归模拟所有的情况</li><li>遇到包含重复元素的情况则回溯</li><li>收集到所有到达递归终点的情况，并返回、</li></ul><p><img src="https://static.vue-js.com/2a030f00-2e8e-11ec-8e64-91fdec0f05a1.png" alt=""></p><p>用代码表示则如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">permute</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">nums</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">res</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [], </span><span style="color:#79B8FF;">path</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">backtracking</span><span style="color:#E1E4E8;">(nums, nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">, []);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> res;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">backtracking</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">k</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">used</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(path.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            res.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(Array.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(path));</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> k; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(used[i]) </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            path.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(n[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">            used[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 同支</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">backtracking</span><span style="color:#E1E4E8;">(n, k, used);</span></span>
<span class="line"><span style="color:#E1E4E8;">            path.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            used[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">permute</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">nums</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">res</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [], </span><span style="color:#005CC5;">path</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">backtracking</span><span style="color:#24292E;">(nums, nums.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">, []);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> res;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">backtracking</span><span style="color:#24292E;">(</span><span style="color:#E36209;">n</span><span style="color:#24292E;">, </span><span style="color:#E36209;">k</span><span style="color:#24292E;">, </span><span style="color:#E36209;">used</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(path.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">            res.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(Array.</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(path));</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> k; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> ) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(used[i]) </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            path.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(n[i]);</span></span>
<span class="line"><span style="color:#24292E;">            used[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 同支</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">backtracking</span><span style="color:#24292E;">(n, k, used);</span></span>
<span class="line"><span style="color:#24292E;">            path.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            used[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="三、总结" tabindex="-1">三、总结 <a class="header-anchor" href="#三、总结" aria-label="Permalink to &quot;三、总结&quot;">​</a></h2><p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p><p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p><p><img src="https://static.vue-js.com/504b5230-2e8e-11ec-8e64-91fdec0f05a1.png" alt=""></p><p>其中三者对应的经典问题如下图：</p><p><img src="https://static.vue-js.com/62cdc910-2e8e-11ec-8e64-91fdec0f05a1.png" alt=""></p><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" target="_blank" rel="noreferrer">https://zh.wikipedia.org/wiki/贪心算法</a></li><li><a href="https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/" target="_blank" rel="noreferrer">https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/</a></li><li><a href="https://cloud.tencent.com/developer/article/1767046" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/1767046</a></li></ul>`,35),e=[o];function r(c,t,E,y,i,u){return n(),a("div",null,e)}const m=s(p,[["render",r]]);export{b as __pageData,m as default};
