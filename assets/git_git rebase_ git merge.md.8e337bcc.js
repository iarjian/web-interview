import{_ as e,o as a,c as t,Q as s}from"./chunks/framework.2eafe199.js";const b=JSON.parse('{"title":"面试官：说说你对git rebase 和 git merge的理解？区别？","description":"","frontmatter":{},"headers":[],"relativePath":"git/git rebase_ git merge.md","filePath":"git/git rebase_ git merge.md","lastUpdated":1694416341000}'),o={name:"git/git rebase_ git merge.md"},c=s('<h1 id="面试官-说说你对git-rebase-和-git-merge的理解-区别" tabindex="-1">面试官：说说你对git rebase 和 git merge的理解？区别？ <a class="header-anchor" href="#面试官-说说你对git-rebase-和-git-merge的理解-区别" aria-label="Permalink to &quot;面试官：说说你对git rebase 和 git merge的理解？区别？&quot;">​</a></h1><p><img src="https://static.vue-js.com/77590970-fdd4-11eb-bc6f-3f06e1491664.png" alt=""></p><h2 id="一、是什么" tabindex="-1">一、是什么 <a class="header-anchor" href="#一、是什么" aria-label="Permalink to &quot;一、是什么&quot;">​</a></h2><p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p><ul><li>git merge</li><li>git rebase</li></ul><p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p><p>用法上两者也十分的简单：</p><h3 id="git-merge" tabindex="-1">git merge <a class="header-anchor" href="#git-merge" aria-label="Permalink to &quot;git merge&quot;">​</a></h3><p>将当前分支合并到指定分支，命令用法如下：</p><div class="language-cmd vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git merge xxx</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git merge xxx</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="git-rebase" tabindex="-1">git rebase <a class="header-anchor" href="#git-rebase" aria-label="Permalink to &quot;git rebase&quot;">​</a></h3><p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p><div class="language-cmd vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git rebase </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">commit</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git rebase </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">commit</span><span style="color:#D73A49;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p><div class="language-cmd vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">git rebase </span><span style="color:#F97583;">--continue</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">git rebase </span><span style="color:#D73A49;">--continue</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="二、分析" tabindex="-1">二、分析 <a class="header-anchor" href="#二、分析" aria-label="Permalink to &quot;二、分析&quot;">​</a></h2><h3 id="git-merge-1" tabindex="-1">git merge <a class="header-anchor" href="#git-merge-1" aria-label="Permalink to &quot;git merge&quot;">​</a></h3><p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p><p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p><p>举个例子，<code>bugfix</code>分支是从<code>master</code>分支分叉出来的，如下所示：</p><p><img src="https://static.vue-js.com/88410a30-fdd4-11eb-991d-334fd31f0201.png" alt=""></p><p>合并<code> bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p><p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p><p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p><p><img src="https://static.vue-js.com/929eb220-fdd4-11eb-991d-334fd31f0201.png" alt=""></p><p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p><p><img src="https://static.vue-js.com/9fdfa3e0-fdd4-11eb-991d-334fd31f0201.png" alt=""></p><p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p><h3 id="git-rebase-1" tabindex="-1">git rebase <a class="header-anchor" href="#git-rebase-1" aria-label="Permalink to &quot;git rebase&quot;">​</a></h3><p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p><p><img src="https://static.vue-js.com/ab2d5120-fdd4-11eb-bc6f-3f06e1491664.png" alt=""></p><p>通过<code>git rebase</code>，会变成如下情况：</p><p><img src="https://static.vue-js.com/b72aed70-fdd4-11eb-991d-334fd31f0201.png" alt=""></p><p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p><p><img src="https://static.vue-js.com/c9ba0e80-fdd4-11eb-bc6f-3f06e1491664.png" alt=""></p><p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p><p><img src="https://static.vue-js.com/dc660660-fdd4-11eb-991d-334fd31f0201.png" alt=""></p><p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p><p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p><h2 id="三、区别" tabindex="-1">三、区别 <a class="header-anchor" href="#三、区别" aria-label="Permalink to &quot;三、区别&quot;">​</a></h2><p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p><h3 id="merge" tabindex="-1">merge <a class="header-anchor" href="#merge" aria-label="Permalink to &quot;merge&quot;">​</a></h3><p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p><p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p><h3 id="rebase" tabindex="-1">rebase <a class="header-anchor" href="#rebase" aria-label="Permalink to &quot;rebase&quot;">​</a></h3><p><code>rebase </code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p><p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/361182707" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/361182707</a></li><li><a href="https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing" target="_blank" rel="noreferrer">https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing</a></li><li><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html" target="_blank" rel="noreferrer">https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html</a></li></ul>',50),r=[c];function i(d,p,l,n,g,h){return a(),t("div",null,r)}const u=e(o,[["render",i]]);export{b as __pageData,u as default};
